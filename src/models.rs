use diesel::prelude::*;
use diesel::sqlite::SqliteConnection;
use diesel::insert_into;
use diesel::result::Error;

// Assuming you have a schema.rs file generated by Diesel
use crate::schema::user;


#[derive(Queryable, Selectable)]
#[diesel(table_name = crate::schema::user)]
#[diesel(check_for_backend(diesel::sqlite::Sqlite))]
pub struct User {
    pub id: i32,
    pub nickname: String,
    pub last_nickname: String,
    pub active: bool,
}

impl User {
    pub fn register(conn: &mut SqliteConnection, nick: &str) -> Result<Self, Error> {
        use crate::schema::user::dsl::*;

        let new_user = NewUser {
            nickname: nick,
            last_nickname: "",
            active: true,
        };

        diesel::insert_into(user)
            .values(&new_user)
            .execute(conn)?;

        // sim isso pode gerar bug, mas estou disposto a comprar o risc
        user.order(id.desc())
            .first(conn)
    }

    pub fn find_user(conn: &mut SqliteConnection, name: String) -> Result<Self, Error>{
        use crate::schema::user::dsl::*;
        
        // Procura o usu√°rio ou joga um erro
        user.filter(nickname.eq(name))
            .first(conn)
    }
}


#[derive(Insertable)]
#[diesel(table_name = user)]
pub struct NewUser<'a> {
    pub nickname: &'a str,
    pub last_nickname: &'a str,
    pub active: bool,
}